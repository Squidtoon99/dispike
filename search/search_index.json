{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python library for building bots to interact with Discord Slash Commands Before we start. This library has not left alpha stage and will have bugs and issues. I ask of you to please remember this when opening issues or creating PRs. This library does not fully match the entire slash commands API spec. Namely Create Followup Message Edit Followup Message Delete Followup Message This library assumes you will be building an independent server to recieve and send requests from/to Discord directly. This may cause higher bandwith usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables a middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this, the bot will only bind to localhost and accept local connections. If you want to do local testing before creating a server, you can use free tools such as ngrok . This library is only tested on python versions 3.9 3.8 3.7 3.6","title":"Home"},{"location":"#before-we-start","text":"This library has not left alpha stage and will have bugs and issues. I ask of you to please remember this when opening issues or creating PRs. This library does not fully match the entire slash commands API spec. Namely Create Followup Message Edit Followup Message Delete Followup Message This library assumes you will be building an independent server to recieve and send requests from/to Discord directly. This may cause higher bandwith usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables a middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this, the bot will only bind to localhost and accept local connections. If you want to do local testing before creating a server, you can use free tools such as ngrok . This library is only tested on python versions 3.9 3.8 3.7 3.6","title":"Before we start."},{"location":"APIRef/Dispike/","text":"Dispike - python library for interacting with discord slash commands via an independently hosted server. Powered by FastAPI interaction: EventHandler property readonly Returns an already initialized EventHandler object. You will use this method to handle incoming commands. Returns: Type Description EventHandler EventHandler: shared EventHandler referenced_application: FastAPI property readonly Returns the internal FastAPI object that was initialized. You are welcome to edit this with the appropriate settings found in the FastAPI docs. Returns: Type Description FastAPI FastAPI: a pre-configured FastAPI object with required middlewares. register: < function RegisterCommands . register at 0x7f3f925203b0 > property readonly Returns a shortcut the RegisterCommands.register function Returns: Type Description <function RegisterCommands.register at 0x7f3f925203b0> RegisterCommands.register: internal RegisterCommands Object shared_client: httpx . Client property readonly Returns a pre-initialized httpx.Client that is used for requests internally. Returns: Type Description httpx.Client httpx.Client: used for network requests to discord. __init__ ( self , client_public_key , bot_token , application_id ) special Initialize Dispike Object Parameters: Name Type Description Default client_public_key str Discord provided client public key. required bot_token str Discord provided bot token. You must create a bot user to view this! required application_id str Discord provided Client ID required Source code in dispike/main.py def __init__ ( self , client_public_key : str , bot_token : str , application_id : str ): \"\"\"Initialize Dispike Object Args: client_public_key (str): Discord provided client public key. bot_token (str): Discord provided bot token. You must create a bot user to view this! application_id (str): Discord provided Client ID \"\"\" self . _bot_token = bot_token self . _application_id = application_id self . _registrator = RegisterCommands ( application_id = self . _application_id , bot_token = self . _bot_token ) self . _internal_application = FastAPI () self . _internal_application . add_middleware ( DiscordVerificationMiddleware , client_public_key = client_public_key ) self . _internal_application . include_router ( router = router ) delete_command ( self , command_id , guild_only = False , guild_id_passed = None ) Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id int Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise will LOG exception and return False. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def delete_command ( self , command_id : int , guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (int): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise will LOG exception and return False. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False edit_command ( self , command_id , new_command , guild_only = False , guild_id_passed = None ) Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id int Command ID required new_command DiscordCommand A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def edit_command ( self , command_id : int , new_command : DiscordCommand , guild_only = False , guild_id_passed = None , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command (DiscordCommand): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if not isinstance ( new_command , ( DiscordCommand , dict )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" _new_command = new_command . dict () try : _send_request = self . _registrator . _client . patch ( _url , headers = self . _registrator . request_headers , json = _new_command ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False get_commands ( self , guild_only = False , guild_id_passed = None ) Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.models.incoming.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise reset_registration ( self , new_bot_token = None , new_application_id = None ) This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Parameters: Name Type Description Default new_bot_token None Description None new_application_id None Description None Returns: Type Description TYPE bool Source code in dispike/main.py def reset_registration ( self , new_bot_token = None , new_application_id = None ): \"\"\"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Args: new_bot_token (None, optional): Description new_application_id (None, optional): Description Returns: TYPE: bool \"\"\" try : if new_bot_token == None : _bot_token = self . _bot_token else : _bot_token = new_bot_token if new_application_id == None : _application_id = self . _application_id else : _application_id = new_application_id self . _registrator = RegisterCommands ( application_id = _application_id , bot_token = _bot_token ) return True except Exception : return False run ( self , port = 5000 ) Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Port to run the bot over. Defaults to 5000. 5000 Source code in dispike/main.py def run ( self , port : int = 5000 ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Port to run the bot over. Defaults to 5000. \"\"\" uvicorn . run ( app = self . referenced_application , port = port )","title":"Dispike"},{"location":"APIRef/Dispike/#dispike.main.Dispike","text":"Dispike - python library for interacting with discord slash commands via an independently hosted server. Powered by FastAPI","title":"dispike.main.Dispike"},{"location":"APIRef/Dispike/#dispike.main.Dispike.interaction","text":"Returns an already initialized EventHandler object. You will use this method to handle incoming commands. Returns: Type Description EventHandler EventHandler: shared EventHandler","title":"interaction"},{"location":"APIRef/Dispike/#dispike.main.Dispike.referenced_application","text":"Returns the internal FastAPI object that was initialized. You are welcome to edit this with the appropriate settings found in the FastAPI docs. Returns: Type Description FastAPI FastAPI: a pre-configured FastAPI object with required middlewares.","title":"referenced_application"},{"location":"APIRef/Dispike/#dispike.main.Dispike.register","text":"Returns a shortcut the RegisterCommands.register function Returns: Type Description <function RegisterCommands.register at 0x7f3f925203b0> RegisterCommands.register: internal RegisterCommands Object","title":"register"},{"location":"APIRef/Dispike/#dispike.main.Dispike.shared_client","text":"Returns a pre-initialized httpx.Client that is used for requests internally. Returns: Type Description httpx.Client httpx.Client: used for network requests to discord.","title":"shared_client"},{"location":"APIRef/Dispike/#dispike.main.Dispike.__init__","text":"Initialize Dispike Object Parameters: Name Type Description Default client_public_key str Discord provided client public key. required bot_token str Discord provided bot token. You must create a bot user to view this! required application_id str Discord provided Client ID required Source code in dispike/main.py def __init__ ( self , client_public_key : str , bot_token : str , application_id : str ): \"\"\"Initialize Dispike Object Args: client_public_key (str): Discord provided client public key. bot_token (str): Discord provided bot token. You must create a bot user to view this! application_id (str): Discord provided Client ID \"\"\" self . _bot_token = bot_token self . _application_id = application_id self . _registrator = RegisterCommands ( application_id = self . _application_id , bot_token = self . _bot_token ) self . _internal_application = FastAPI () self . _internal_application . add_middleware ( DiscordVerificationMiddleware , client_public_key = client_public_key ) self . _internal_application . include_router ( router = router )","title":"__init__()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.delete_command","text":"Deletes a command, provided with a command_id Parameters: Name Type Description Default command_id int Command ID required required guild_only bool Whether to be a global action or target a guild. Defaults to False. False guild_id_passed [type] Guild ID if guild_only is set to True. Defaults to None. None Returns: Type Description bool bool: True if status code is 201, otherwise will LOG exception and return False. Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def delete_command ( self , command_id : int , guild_only = False , guild_id_passed = None ) -> bool : \"\"\"Deletes a command, provided with a command_id Args: command_id (int): Command ID required guild_only (bool, optional): Whether to be a global action or target a guild. Defaults to False. guild_id_passed ([type], optional): Guild ID if guild_only is set to True. Defaults to None. Returns: bool: True if status code is 201, otherwise will LOG exception and return False. Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" try : _send_request = self . _registrator . _client . delete ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code != 204 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return True except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False","title":"delete_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.edit_command","text":"Edits a command provided with a command_id and a valid new command. Parameters: Name Type Description Default command_id int Command ID required new_command DiscordCommand A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) required guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description DiscordCommand DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Exceptions: Type Description TypeError Invalid types passed. DiscordAPIError any Discord returned errors. Source code in dispike/main.py def edit_command ( self , command_id : int , new_command : DiscordCommand , guild_only = False , guild_id_passed = None , ) -> DiscordCommand : \"\"\"Edits a command provided with a command_id and a valid new command. Args: command_id (int): Command ID new_command (DiscordCommand): A valid DiscordCommand object (or a dict with proper syntax, if a dict is passed no verification will be made and discord will return the syntax error) guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: DiscordCommand: Returns the DiscordCommand object created. (Will return a DiscordCommand irregardless of new_command) Raises: TypeError: Invalid types passed. DiscordAPIError: any Discord returned errors. \"\"\" if not isinstance ( new_command , ( DiscordCommand , dict )): raise TypeError ( \"New command must be a DiscordCommand or a valid dict.\" ) if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands/ { command_id } \" else : _url = f \"/commands/ { command_id } \" _new_command = new_command . dict () try : _send_request = self . _registrator . _client . patch ( _url , headers = self . _registrator . request_headers , json = _new_command ) if _send_request . status_code != 200 : raise DiscordAPIError ( _send_request . status_code , _send_request . text ) return DiscordCommand ( ** _send_request . json ()) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) return False except Exception : logger . exception ( \"Unknown exception returned\" ) return False","title":"edit_command()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.get_commands","text":"Returns a list of DiscordCommands either globally or for a specific guild. Parameters: Name Type Description Default guild_only bool whether to target a guild. Defaults to False. False guild_id_passed [type] guild id if guild_only is set to True. Defaults to None. None Returns: Type Description List[dispike.models.incoming.IncomingApplicationCommand] typing.List[DiscordCommand]: Array of DiscordCommand Exceptions: Type Description DiscordAPIError any Discord returned errors. Source code in dispike/main.py def get_commands ( self , guild_only = False , guild_id_passed = None ) -> typing . List [ IncomingApplicationCommand ]: \"\"\"Returns a list of ``DiscordCommands`` either globally or for a specific guild. Args: guild_only (bool, optional): whether to target a guild. Defaults to False. guild_id_passed ([type], optional): guild id if guild_only is set to True. Defaults to None. Returns: typing.List[DiscordCommand]: Array of DiscordCommand Raises: DiscordAPIError: any Discord returned errors. \"\"\" if guild_only == True : if guild_id_passed == False : raise TypeError ( \"You cannot have guild_only == True and NOT pass any guild id.\" ) _url = f \"/guilds/ { guild_id_passed } /commands\" else : _url = f \"/commands\" try : _send_request = self . _registrator . _client . get ( _url , headers = self . _registrator . request_headers ) if _send_request . status_code == 200 : return [ IncomingApplicationCommand ( ** x ) for x in _send_request . json ()] raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except DiscordAPIError : logger . exception ( \"Discord API Failure.\" ) raise except Exception : logger . exception ( \"Unknown exception returned\" ) raise","title":"get_commands()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.reset_registration","text":"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Parameters: Name Type Description Default new_bot_token None Description None new_application_id None Description None Returns: Type Description TYPE bool Source code in dispike/main.py def reset_registration ( self , new_bot_token = None , new_application_id = None ): \"\"\"This method resets the built-in RgeisterCommands. You should not have to call this method directly. Call it only if you change the client id or bot token. Args: new_bot_token (None, optional): Description new_application_id (None, optional): Description Returns: TYPE: bool \"\"\" try : if new_bot_token == None : _bot_token = self . _bot_token else : _bot_token = new_bot_token if new_application_id == None : _application_id = self . _application_id else : _application_id = new_application_id self . _registrator = RegisterCommands ( application_id = _application_id , bot_token = _bot_token ) return True except Exception : return False","title":"reset_registration()"},{"location":"APIRef/Dispike/#dispike.main.Dispike.run","text":"Runs the bot with the already-installed Uvicorn webserver. Parameters: Name Type Description Default port int Port to run the bot over. Defaults to 5000. 5000 Source code in dispike/main.py def run ( self , port : int = 5000 ): \"\"\"Runs the bot with the already-installed Uvicorn webserver. Args: port (int, optional): Port to run the bot over. Defaults to 5000. \"\"\" uvicorn . run ( app = self . referenced_application , port = port )","title":"run()"},{"location":"APIRef/EventHandler/","text":"A relatively simple \"event handler\". Pass in async functions and provide a string, and it will call it Attributes: Name Type Description callbacks dict dict of names --> functions check_event_exists ( self , event ) Checks if the event in .callbacks Parameters: Name Type Description Default event str event name required Returns: Type Description bool bool: returns if the event is in callbacks. Source code in dispike/eventer.py def check_event_exists ( self , event : str ) -> bool : \"\"\"Checks if the event in ``.callbacks`` Args: event (str): event name Returns: bool: returns if the event is in callbacks. \"\"\" return event in self . callbacks emit ( self , event , * args , ** kwargs ) async 'Emits' an event. It will basically call the function from .callbacks and return the function result Parameters: Name Type Description Default event str Event name required *args extra arguments to pass () **kwargs extra kwargs to pass {} Returns: Type Description function result returns the function result Exceptions: Type Description TypeError raises if event is not registered. Source code in dispike/eventer.py async def emit ( self , event : str , * args , ** kwargs ): \"\"\"'Emits' an event. It will basically call the function from .callbacks and return the function result Args: event (str): Event name *args: extra arguments to pass **kwargs: extra kwargs to pass Returns: function result: returns the function result Raises: TypeError: raises if event is not registered. \"\"\" if event not in self . callbacks : raise TypeError ( f \"event { event } does not have a corresponding handler.\" ) return await self . callbacks [ event ]( ** kwargs ) on ( self , event , func = None ) A wrapper over an async function, registers it in .callbacks. Parameters: Name Type Description Default event str Event name required func None function to wrap around None Returns: Type Description <function> returns the wrapped function Source code in dispike/eventer.py def on ( self , event , func = None ): \"\"\"A wrapper over an async function, registers it in .callbacks. Args: event (str): Event name func (None, optional): function to wrap around Returns: <function>: returns the wrapped function \"\"\" def on ( func ): if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Function must be a async function.\" ) if event not in self . callbacks : logger . debug ( f \"Added { event } to corresponding function to { func } \" ) self . callbacks [ event ] = func else : raise TypeError ( \"Events can only have one corresponding handler.\" ) return func return on ( func ) if func else on view_event_function_return_type ( self , event ) Get type hint for event functions Parameters: Name Type Description Default event str Event name required Returns: Type Description dict dict: Returns .get_type_hints for event Source code in dispike/eventer.py def view_event_function_return_type ( self , event : str ) -> dict : \"\"\"Get type hint for event functions Args: event (str): Event name Returns: dict: Returns .get_type_hints for event \"\"\" return typing . get_type_hints ( self . callbacks [ event ])","title":"EventHandler"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler","text":"A relatively simple \"event handler\". Pass in async functions and provide a string, and it will call it Attributes: Name Type Description callbacks dict dict of names --> functions","title":"dispike.eventer.EventHandler"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.check_event_exists","text":"Checks if the event in .callbacks Parameters: Name Type Description Default event str event name required Returns: Type Description bool bool: returns if the event is in callbacks. Source code in dispike/eventer.py def check_event_exists ( self , event : str ) -> bool : \"\"\"Checks if the event in ``.callbacks`` Args: event (str): event name Returns: bool: returns if the event is in callbacks. \"\"\" return event in self . callbacks","title":"check_event_exists()"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.emit","text":"'Emits' an event. It will basically call the function from .callbacks and return the function result Parameters: Name Type Description Default event str Event name required *args extra arguments to pass () **kwargs extra kwargs to pass {} Returns: Type Description function result returns the function result Exceptions: Type Description TypeError raises if event is not registered. Source code in dispike/eventer.py async def emit ( self , event : str , * args , ** kwargs ): \"\"\"'Emits' an event. It will basically call the function from .callbacks and return the function result Args: event (str): Event name *args: extra arguments to pass **kwargs: extra kwargs to pass Returns: function result: returns the function result Raises: TypeError: raises if event is not registered. \"\"\" if event not in self . callbacks : raise TypeError ( f \"event { event } does not have a corresponding handler.\" ) return await self . callbacks [ event ]( ** kwargs )","title":"emit()"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.on","text":"A wrapper over an async function, registers it in .callbacks. Parameters: Name Type Description Default event str Event name required func None function to wrap around None Returns: Type Description <function> returns the wrapped function Source code in dispike/eventer.py def on ( self , event , func = None ): \"\"\"A wrapper over an async function, registers it in .callbacks. Args: event (str): Event name func (None, optional): function to wrap around Returns: <function>: returns the wrapped function \"\"\" def on ( func ): if not inspect . iscoroutinefunction ( func ): raise TypeError ( \"Function must be a async function.\" ) if event not in self . callbacks : logger . debug ( f \"Added { event } to corresponding function to { func } \" ) self . callbacks [ event ] = func else : raise TypeError ( \"Events can only have one corresponding handler.\" ) return func return on ( func ) if func else on","title":"on()"},{"location":"APIRef/EventHandler/#dispike.eventer.EventHandler.view_event_function_return_type","text":"Get type hint for event functions Parameters: Name Type Description Default event str Event name required Returns: Type Description dict dict: Returns .get_type_hints for event Source code in dispike/eventer.py def view_event_function_return_type ( self , event : str ) -> dict : \"\"\"Get type hint for event functions Args: event (str): Event name Returns: dict: Returns .get_type_hints for event \"\"\" return typing . get_type_hints ( self . callbacks [ event ])","title":"view_event_function_return_type()"},{"location":"APIRef/RegCommands/","text":"This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async. bot_token property writable You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value request_headers property readonly Return a valid header for authorization Returns: Type Description dict a valid header for authorization __init__ ( self , application_id , bot_token ) special Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/register/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" ) register ( self , command , guild_only = False , guild_to_target = None ) Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict () _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = command . dict () ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"RegisterCommands"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands","text":"This object contains methods to help registering a command to Discord. While you shouldn't need to import this directly, it's still accessible if you prefer not to initalize a Dispike object. Important to remember all methods are not async.","title":"dispike.register.registrator.RegisterCommands"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.bot_token","text":"You cannot view the bot_token directly, but you can still 'update' it. Exceptions: Type Description PermissionError If you attempt to view the bot token without a new value","title":"bot_token"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.request_headers","text":"Return a valid header for authorization Returns: Type Description dict a valid header for authorization","title":"request_headers"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.__init__","text":"Initalize object provided with application_id and a bot token Parameters: Name Type Description Default application_id str Client ID required bot_token str Bot user Token required Source code in dispike/register/registrator.py def __init__ ( self , application_id : str , bot_token : str ): \"\"\"Initalize object provided with application_id and a bot token Args: application_id (str): Client ID bot_token (str): Bot user Token \"\"\" self . __bot_token = bot_token self . _application_id = application_id self . _client = Client ( base_url = f \"https://discord.com/api/v8/applications/ { self . _application_id } /\" )","title":"__init__()"},{"location":"APIRef/RegCommands/#dispike.register.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict () _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = command . dict () ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"register()"},{"location":"Models/","text":"Models Models are responses or requests to and from discord that has been verified. Data can be accessed in a pythonic way of attrbiutes rather then dictionaries. Info If you want a more low-level or want to transport models (pickling) you can access attributes .to_dict or .to_json . Models have been split into sections. - Incoming - Outgoing Outgoing models are usually created by the user and and meant to be sent to discord, and have the strictest validation. They are easily editable by property. Incoming models are usually models that have been translated from Discord themselves, and have been validated. While it's possible to edit the attributes, no function provided by Dispike will accept them. Treat them as read-only. Info in certain circumstances, you can convert Incoming models to Outgoing, simply pass .to_dict of the incoming object to the appropriate outgoing object by doing OutgoingObject(**IncomingObject) .","title":"Info"},{"location":"Models/#models","text":"Models are responses or requests to and from discord that has been verified. Data can be accessed in a pythonic way of attrbiutes rather then dictionaries. Info If you want a more low-level or want to transport models (pickling) you can access attributes .to_dict or .to_json . Models have been split into sections. - Incoming - Outgoing Outgoing models are usually created by the user and and meant to be sent to discord, and have the strictest validation. They are easily editable by property. Incoming models are usually models that have been translated from Discord themselves, and have been validated. While it's possible to edit the attributes, no function provided by Dispike will accept them. Treat them as read-only. Info in certain circumstances, you can convert Incoming models to Outgoing, simply pass .to_dict of the incoming object to the appropriate outgoing object by doing OutgoingObject(**IncomingObject) .","title":"Models"},{"location":"Models/Incoming/","text":"Incoming Objects IncomingApplicationCommand pydantic-model an Incoming Application command, this is not intended for you to edit, and will not be accepted in any function IncomingDiscordInteraction pydantic-model An incoming discord interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. IncomingDiscordOption pydantic-model An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand IncomingDiscordOptionList pydantic-model An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand","title":"Incoming"},{"location":"Models/Incoming/#incoming-objects","text":"","title":"Incoming Objects"},{"location":"Models/Incoming/#dispike.models.incoming","text":"","title":"dispike.models.incoming"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingApplicationCommand","text":"an Incoming Application command, this is not intended for you to edit, and will not be accepted in any function","title":"IncomingApplicationCommand"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingDiscordInteraction","text":"An incoming discord interaction, this is not intended for you to edit, and will not be accepted as an argument in any function.","title":"IncomingDiscordInteraction"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingDiscordOption","text":"An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand","title":"IncomingDiscordOption"},{"location":"Models/Incoming/#dispike.models.incoming.IncomingDiscordOptionList","text":"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand","title":"IncomingDiscordOptionList"},{"location":"Models/Outgoing/","text":"Outgoing Models To import these models from dispike.register.models.options import < Object > Warning Version >=v0.5.7a adds support for VSCode to auto-complete attributes when creating these models. CommandChoice pydantic-model Represents a key-value command choice. CommandOption pydantic-model Represents a standard command option (not a subcommand). CommandTypes Easy access to command types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6 DiscordCommand pydantic-model Represents a discord command. SubcommandOption pydantic-model Represents a subcommand, usually you would put this as an option in a DiscordCommand","title":"Outgoing"},{"location":"Models/Outgoing/#outgoing-models","text":"To import these models from dispike.register.models.options import < Object > Warning Version >=v0.5.7a adds support for VSCode to auto-complete attributes when creating these models.","title":"Outgoing Models"},{"location":"Models/Outgoing/#dispike.register.models.options","text":"","title":"dispike.register.models.options"},{"location":"Models/Outgoing/#dispike.register.models.options.CommandChoice","text":"Represents a key-value command choice.","title":"CommandChoice"},{"location":"Models/Outgoing/#dispike.register.models.options.CommandOption","text":"Represents a standard command option (not a subcommand).","title":"CommandOption"},{"location":"Models/Outgoing/#dispike.register.models.options.CommandTypes","text":"Easy access to command types. Attributes: Name Type Description BOOLEAN int Represents Type 5 CHANNEL int Represents Type 7 INTEGER int Represents Type 4 ROLE int Represents Type 8 STRING int Represents Type 3 SUB_COMMAND int Represents Type 1 SUB_COMMAND_GROUP int Represents Type 2 USER int Represents Type 6","title":"CommandTypes"},{"location":"Models/Outgoing/#dispike.register.models.options.DiscordCommand","text":"Represents a discord command.","title":"DiscordCommand"},{"location":"Models/Outgoing/#dispike.register.models.options.SubcommandOption","text":"Represents a subcommand, usually you would put this as an option in a DiscordCommand","title":"SubcommandOption"},{"location":"Models/Read%20Only/Incoming/","text":"from pydantic import BaseModel , ValidationError , validator import typing from .discord_types.member import Member from ..register.models import CommandOption , SubcommandOption try : from typing import Literal except ImportError : # backport from typing_extensions import Literal class IncomingDiscordOption ( BaseModel ): \"\"\"An incoming discord option, this is not intended for you to edit, and will not be accepted as an argument in any function nor will be accepted as a value in DiscordCommand \"\"\" name : str value : str class IncomingDiscordOptionList ( BaseModel ): \"\"\"An incoming discord option list, this is not intended for you to edit, and will not be accepted as an argument in any function nor accepted in DiscordCommand \"\"\" class Config : arbitary_types_allowed = True id : str name : str options : typing . List [ IncomingDiscordOption ] class IncomingDiscordInteraction ( BaseModel ): \"\"\"An incoming discord interaction, this is not intended for you to edit, and will not be accepted as an argument in any function. \"\"\" class Config : arbitary_types_allowed = True type : Literal [ 2 , 3 , 4 , 5 , 6 , 7 , 8 ] # 1 is removed, this lib will handle PING id : int data : IncomingDiscordOptionList guild_id : int channel_id : int member : Member token : str version : typing . Optional [ Literal [ 1 ]] = None class IncomingApplicationCommand ( BaseModel ): \"\"\"an Incoming Application command, this is not intended for you to edit, and will not be accepted in any function \"\"\" class Config : arbitary_types_allowed = True id : int application_id : int name : str description : str options : typing . List [ typing . Union [ CommandOption , SubcommandOption ]]","title":"Incoming"},{"location":"responses/","text":"Responses Responses are what are returned to Discord. Either immediately or later. Immediate Responses These responses are immediately returned after a request is received. To create a proper response, you will need the DiscordResponse object. Responses For Later If your request requires a request to be sent later (such as a long computational value.) You can simply return a NotReadyResponse. Provided with the bot instance, and a IncomingDiscordInteraction (which is the context in your handler.), it will provide methods for you to easily send your response when you are ready. Warning The token to send the response expires after 15 minutes. \u200b","title":"Info"},{"location":"responses/#responses","text":"Responses are what are returned to Discord. Either immediately or later.","title":"Responses"},{"location":"responses/#immediate-responses","text":"These responses are immediately returned after a request is received. To create a proper response, you will need the DiscordResponse object.","title":"Immediate Responses"},{"location":"responses/#responses-for-later","text":"If your request requires a request to be sent later (such as a long computational value.) You can simply return a NotReadyResponse. Provided with the bot instance, and a IncomingDiscordInteraction (which is the context in your handler.), it will provide methods for you to easily send your response when you are ready. Warning The token to send the response expires after 15 minutes. \u200b","title":"Responses For Later"},{"location":"responses/readyresponse/","text":"Ready Response Represents an outgoing Discord Response Attributes: Name Type Description content str A plain-text response to a user tts bool bool returning if the message should be spoken via tts. embeds dict a List representing .to_dict of an Embed object. response dict a valid response represented in a dict, to later be converted to JSON. content: str property writable Either set or view the plain-text response to the user. Returns: Type Description str str: Content provided embeds: List [ dict ] property readonly Returns a list of embeds to send to. Returns: Type Description List[dict] typing.List[dict]: Embeds represented as a dict. response: dict property readonly A generated valid discord response Returns: Type Description dict dict: a valid discord response. tts: bool property writable Either set or view the tts attribute for the user. Returns: Type Description bool bool: tts __init__ ( self , content = None , tts = False , embeds = [], show_user_input = False ) special Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Parameters: Name Type Description Default content str A plain-text response to a user None tts bool bool returning if the message should be spoken via tts False embeds List[dispike.helper.embed.Embed] a List representing .to_dict of an Embed object [] show_user_input bool Whether to delete the user's message of calling the command after responding. False Source code in dispike/response.py def __init__ ( self , content : str = None , tts : bool = False , embeds : typing . List [ Embed ] = [], show_user_input : bool = False , ): \"\"\"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Args: content (str, optional): A plain-text response to a user tts (bool, optional): bool returning if the message should be spoken via tts embeds (typing.List[Embed], optional): a List representing .to_dict of an Embed object show_user_input (bool, optional): Whether to delete the user's message of calling the command after responding. \"\"\" if content != None : if isinstance ( content , str ) == False : raise TypeError ( f \"Content must be a string\" ) elif content == \"\" : content = None # if isinstance(content, str) == False or content == \"\" or content != None: # raise TypeError(f\"content must be a string. recieved: {content}\") if isinstance ( tts , bool ) == False : raise TypeError ( \"tts must be a bool\" ) self . _content = content self . _tts = tts self . _embeds = [ x . to_dict () for x in embeds ] if show_user_input == False : self . _type_response = 3 else : self . _type_response = 4 add_new_embed ( self , embed_to_add ) Append a new embed, provided with a proper Embed object Parameters: Name Type Description Default embed_to_add Embed Proper Embed Object required Exceptions: Type Description TypeError Raised if you do not pass a proper Embed object. Source code in dispike/response.py def add_new_embed ( self , embed_to_add : Embed ): \"\"\"Append a new embed, provided with a proper Embed object Args: embed_to_add (Embed): Proper Embed Object Raises: TypeError: Raised if you do not pass a proper Embed object. \"\"\" if isinstance ( embed_to_add , Embed ): self . _embeds . append ( embed_to_add . to_dict ()) else : raise TypeError ( \"embed must be a Embed object.\" )","title":"Ready Responses"},{"location":"responses/readyresponse/#ready-response","text":"","title":"Ready Response"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse","text":"Represents an outgoing Discord Response Attributes: Name Type Description content str A plain-text response to a user tts bool bool returning if the message should be spoken via tts. embeds dict a List representing .to_dict of an Embed object. response dict a valid response represented in a dict, to later be converted to JSON.","title":"dispike.response.DiscordResponse"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.content","text":"Either set or view the plain-text response to the user. Returns: Type Description str str: Content provided","title":"content"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.embeds","text":"Returns a list of embeds to send to. Returns: Type Description List[dict] typing.List[dict]: Embeds represented as a dict.","title":"embeds"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.response","text":"A generated valid discord response Returns: Type Description dict dict: a valid discord response.","title":"response"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.tts","text":"Either set or view the tts attribute for the user. Returns: Type Description bool bool: tts","title":"tts"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.__init__","text":"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Parameters: Name Type Description Default content str A plain-text response to a user None tts bool bool returning if the message should be spoken via tts False embeds List[dispike.helper.embed.Embed] a List representing .to_dict of an Embed object [] show_user_input bool Whether to delete the user's message of calling the command after responding. False Source code in dispike/response.py def __init__ ( self , content : str = None , tts : bool = False , embeds : typing . List [ Embed ] = [], show_user_input : bool = False , ): \"\"\"Initialize a DiscordResponse, you can either pass data into here, or simply create a DiscordResponse() and edit via properties. Args: content (str, optional): A plain-text response to a user tts (bool, optional): bool returning if the message should be spoken via tts embeds (typing.List[Embed], optional): a List representing .to_dict of an Embed object show_user_input (bool, optional): Whether to delete the user's message of calling the command after responding. \"\"\" if content != None : if isinstance ( content , str ) == False : raise TypeError ( f \"Content must be a string\" ) elif content == \"\" : content = None # if isinstance(content, str) == False or content == \"\" or content != None: # raise TypeError(f\"content must be a string. recieved: {content}\") if isinstance ( tts , bool ) == False : raise TypeError ( \"tts must be a bool\" ) self . _content = content self . _tts = tts self . _embeds = [ x . to_dict () for x in embeds ] if show_user_input == False : self . _type_response = 3 else : self . _type_response = 4","title":"__init__()"},{"location":"responses/readyresponse/#dispike.response.DiscordResponse.add_new_embed","text":"Append a new embed, provided with a proper Embed object Parameters: Name Type Description Default embed_to_add Embed Proper Embed Object required Exceptions: Type Description TypeError Raised if you do not pass a proper Embed object. Source code in dispike/response.py def add_new_embed ( self , embed_to_add : Embed ): \"\"\"Append a new embed, provided with a proper Embed object Args: embed_to_add (Embed): Proper Embed Object Raises: TypeError: Raised if you do not pass a proper Embed object. \"\"\" if isinstance ( embed_to_add , Embed ): self . _embeds . append ( embed_to_add . to_dict ()) else : raise TypeError ( \"embed must be a Embed object.\" )","title":"add_new_embed()"},{"location":"tutorial/Configuring%20commands/","text":"Configuring commands Creating a command is very similar to creating it in JSON, however this library will assist you in making sure the outcome is valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to intergrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.register.models import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.register.models import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not convered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command. Source from pydantic import BaseModel , validator , Extra import typing from pydantic.error_wrappers import ValidationError from pydantic.errors import ArbitraryTypeError try : from typing import Literal except ImportError : # backport from typing_extensions import Literal class CommandTypes : \"\"\"Easy access to command types. Attributes: BOOLEAN (int): Represents Type 5 CHANNEL (int): Represents Type 7 INTEGER (int): Represents Type 4 ROLE (int): Represents Type 8 STRING (int): Represents Type 3 SUB_COMMAND (int): Represents Type 1 SUB_COMMAND_GROUP (int): Represents Type 2 USER (int): Represents Type 6 \"\"\" SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 class CommandChoice ( BaseModel ): \"\"\"Represents a key-value command choice. \"\"\" name : str value : str class CommandOption ( BaseModel ): \"\"\"Represents a standard command option (not a subcommand). \"\"\" class Config : arbitrary_types_allowed = True extra = Extra . allow name : str description : str type : int required : bool = False choices : typing . Optional [ typing . Union [ typing . List [ dict ], typing . List [ CommandChoice ]] ] = [] # options: typing.Optional[typing.Union[typing.List[CommandChoice]]] # @validator(\"options\") # def options_allow_only_if_subcommand(cls, v): # if cls.type != 1: # raise ValidationError(\"Type must be 1 in order to have options.\") # return v class SubcommandOption ( BaseModel ): \"\"\"Represents a subcommand, usually you would put this as an option in a DiscordCommand \"\"\" class Config : arbitrary_types_allowed = True name : str description : str type : Literal [ 2 ] = 2 options : typing . List [ CommandOption ] @validator ( \"options\" ) def options_must_contain_type_1 ( cls , v ): # pylint: disable=no-self-argument item : CommandOption for item_location , item in enumerate ( v ): if item . type != 1 : raise ValidationError ( f \"CommandOptions located in < { item_location } > must be have type of 1 due to parent being a subcommand.\" ) return v class DiscordCommand ( BaseModel ): \"\"\"Represents a discord command. \"\"\" name : str description : str options : typing . List [ typing . Union [ SubcommandOption , CommandOption ]]","title":"Configuring Commands"},{"location":"tutorial/Configuring%20commands/#configuring-commands","text":"Creating a command is very similar to creating it in JSON, however this library will assist you in making sure the outcome is valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to intergrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.register.models import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.register.models import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not convered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command.","title":"Configuring commands"},{"location":"tutorial/Configuring%20commands/#source","text":"from pydantic import BaseModel , validator , Extra import typing from pydantic.error_wrappers import ValidationError from pydantic.errors import ArbitraryTypeError try : from typing import Literal except ImportError : # backport from typing_extensions import Literal class CommandTypes : \"\"\"Easy access to command types. Attributes: BOOLEAN (int): Represents Type 5 CHANNEL (int): Represents Type 7 INTEGER (int): Represents Type 4 ROLE (int): Represents Type 8 STRING (int): Represents Type 3 SUB_COMMAND (int): Represents Type 1 SUB_COMMAND_GROUP (int): Represents Type 2 USER (int): Represents Type 6 \"\"\" SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 class CommandChoice ( BaseModel ): \"\"\"Represents a key-value command choice. \"\"\" name : str value : str class CommandOption ( BaseModel ): \"\"\"Represents a standard command option (not a subcommand). \"\"\" class Config : arbitrary_types_allowed = True extra = Extra . allow name : str description : str type : int required : bool = False choices : typing . Optional [ typing . Union [ typing . List [ dict ], typing . List [ CommandChoice ]] ] = [] # options: typing.Optional[typing.Union[typing.List[CommandChoice]]] # @validator(\"options\") # def options_allow_only_if_subcommand(cls, v): # if cls.type != 1: # raise ValidationError(\"Type must be 1 in order to have options.\") # return v class SubcommandOption ( BaseModel ): \"\"\"Represents a subcommand, usually you would put this as an option in a DiscordCommand \"\"\" class Config : arbitrary_types_allowed = True name : str description : str type : Literal [ 2 ] = 2 options : typing . List [ CommandOption ] @validator ( \"options\" ) def options_must_contain_type_1 ( cls , v ): # pylint: disable=no-self-argument item : CommandOption for item_location , item in enumerate ( v ): if item . type != 1 : raise ValidationError ( f \"CommandOptions located in < { item_location } > must be have type of 1 due to parent being a subcommand.\" ) return v class DiscordCommand ( BaseModel ): \"\"\"Represents a discord command. \"\"\" name : str description : str options : typing . List [ typing . Union [ SubcommandOption , CommandOption ]]","title":"Source"},{"location":"tutorial/Getting%20Started/","text":"Getting Started Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice An example bot is available here","title":"Getting Started"},{"location":"tutorial/Getting%20Started/#getting-started","text":"Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice An example bot is available here","title":"Getting Started"},{"location":"tutorial/Registering%20Commands/","text":"Registering Commands We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register . ( command_to_be_created ) Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict () _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = command . dict () ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#registering-commands","text":"We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register . ( command_to_be_created )","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#dispike.register.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict () _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = command . dict () ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"dispike.register.registrator.RegisterCommands.register"},{"location":"tutorial/Running%20the%20bot/","text":"Running your bot. Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckilly there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok. Start ngrok. Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification. Start the bot. There is multiple ways to run the bot. We\u2019re going to the most simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass. Run some commands. Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Running The Bot"},{"location":"tutorial/Running%20the%20bot/#running-your-bot","text":"Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckilly there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok.","title":"Running your bot."},{"location":"tutorial/Running%20the%20bot/#start-ngrok","text":"Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification.","title":"Start ngrok."},{"location":"tutorial/Running%20the%20bot/#start-the-bot","text":"There is multiple ways to run the bot. We\u2019re going to the most simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass.","title":"Start the bot."},{"location":"tutorial/Running%20the%20bot/#run-some-commands","text":"Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Run some commands."},{"location":"tutorial/Writing%20the%20handler/","text":"Writing your first handler. You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , NotReadyResponse or a dict . Warning If you return a dict , it will not verified and Dispike will assume that\u2019s valid and return the result to discord. Your function must accept the same number of arugments you registered with discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an arugment named person , the function arugment must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python Incoming Context Eariler you learned that you must account for an extra arugment due to Dispike also passing a context about the command to your arugment. Incoming context is type hinted, and your IDE should be able to auto-complete attributes. Writing your function from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . interaction . on ( \"wave\" ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.interaction.on(\u2018wave\u2019) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument named \u201cperson\u201d, as well as the context that we will be reciveing. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests faster, as Dispike would not have to guess what your response type is.","title":"Writing The Handler"},{"location":"tutorial/Writing%20the%20handler/#writing-your-first-handler","text":"You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , NotReadyResponse or a dict . Warning If you return a dict , it will not verified and Dispike will assume that\u2019s valid and return the result to discord. Your function must accept the same number of arugments you registered with discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an arugment named person , the function arugment must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python","title":"Writing your first handler."},{"location":"tutorial/Writing%20the%20handler/#incoming-context","text":"Eariler you learned that you must account for an extra arugment due to Dispike also passing a context about the command to your arugment. Incoming context is type hinted, and your IDE should be able to auto-complete attributes.","title":"Incoming Context"},{"location":"tutorial/Writing%20the%20handler/#writing-your-function","text":"from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . interaction . on ( \"wave\" ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.interaction.on(\u2018wave\u2019) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument named \u201cperson\u201d, as well as the context that we will be reciveing. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests faster, as Dispike would not have to guess what your response type is.","title":"Writing your function"}]}