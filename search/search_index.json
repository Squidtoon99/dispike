{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Python library for building bots to interact with Discord Slash Commands Before we start. This library has not left alpha stage and will have bugs and issues. I ask of you to please remember this when opening issues or creating PRs. This library does not fully match the entire slash commands API spec. Namely Create Followup Message Edit Followup Message Delete Followup Message This library assumes you will be building an independent server to recieve and send requests from/to Discord directly. This may cause higher bandwith usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables a middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this, the bot will only bind to localhost and accept local connections. If you want to do local testing before creating a server, you can use free tools such as ngrok . This library is only tested on python versions 3.9 3.8 3.7 3.6","title":"Home"},{"location":"#before-we-start","text":"This library has not left alpha stage and will have bugs and issues. I ask of you to please remember this when opening issues or creating PRs. This library does not fully match the entire slash commands API spec. Namely Create Followup Message Edit Followup Message Delete Followup Message This library assumes you will be building an independent server to recieve and send requests from/to Discord directly. This may cause higher bandwith usages and incur costs with your cloud provider. If you prefer to listen over the Discord gateway, you should follow the progress of Discord.py instead. This library enables a middleware to verify and accept connections only from Discord per documentation. Although Discord is trusted, you should operate this bot behind a reverse proxy such as Nginx or Caddy, because of this, the bot will only bind to localhost and accept local connections. If you want to do local testing before creating a server, you can use free tools such as ngrok . This library is only tested on python versions 3.9 3.8 3.7 3.6","title":"Before we start."},{"location":"tutorial/Configuring%20commands/","text":"Configuring commands Creating a command is very similar to creating it in JSON, however this library will assist you in making sure the outcome is valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to intergrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.register.models import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.register.models import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not convered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command. Source from pydantic import BaseModel , validator , Extra import typing from pydantic.error_wrappers import ValidationError from pydantic.errors import ArbitraryTypeError try : from typing import Literal except ImportError : # backport from typing_extensions import Literal class CommandTypes : SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 class CommandChoice ( BaseModel ): name : str value : str class CommandOption ( BaseModel ): class Config : arbitrary_types_allowed = True extra = Extra . allow name : str description : str type : int required : bool = False choices : typing . Optional [ typing . Union [ typing . List [ dict ], typing . List [ CommandChoice ]] ] = [] # options: typing.Optional[typing.Union[typing.List[CommandChoice]]] # @validator(\"options\") # def options_allow_only_if_subcommand(cls, v): # if cls.type != 1: # raise ValidationError(\"Type must be 1 in order to have options.\") # return v class SubcommandOption ( BaseModel ): class Config : arbitrary_types_allowed = True name : str description : str type : Literal [ 2 ] = 2 options : typing . List [ CommandOption ] @validator ( \"options\" ) def options_must_contain_type_1 ( cls , v ): # pylint: disable=no-self-argument item : CommandOption for item_location , item in enumerate ( v ): if item . type != 1 : raise ValidationError ( f \"CommandOptions located in < { item_location } > must be have type of 1 due to parent being a subcommand.\" ) return v class DiscordCommand ( BaseModel ): name : str description : str options : typing . List [ typing . Union [ SubcommandOption , CommandOption ]]","title":"Configuring Commands"},{"location":"tutorial/Configuring%20commands/#configuring-commands","text":"Creating a command is very similar to creating it in JSON, however this library will assist you in making sure the outcome is valid schema for Discord. You should still learn how to build commands by reading the documentation on Discord. Internally this is powered by pydantic . There are third-party plugins to intergrate with your favorite IDEs to enable auto-completion when typing. Caution Autocompletion for creating new models under DiscordCommand, CommandChoice, CommandOption, SubcommandOption, CommandTypes on VSCode is broken. (follow discussion here samuelcolvin/pydantic#650 , microsoft/python-language-server#1898 ). PyCharm appears to work using an external plugin. Let's get started # Import from dispike.register.models import DiscordCommand , CommandOption , CommandChoice , CommandTypes from dispike.register.models import ( DiscordCommand , CommandOption , CommandChoice , CommandTypes ) These are the models that you will need to get started. Think of models as blueprints. Info You can go more advanced by also importing [SubcommandOption], but that's more advanced and is not convered in this tutorial. Let's create a command. The user will interact with this command such as. / wave < discord user to send wave to > This is simple to create. Let's make it. command_to_be_created = DiscordCommand ( name = \"wave\" # this is the main command name., description = \"Send a wave to a nice person! \ud83d\udc4b \" , options = [ CommandOption ( name = \"person\" # this is the attribute assigned to the value passed., description = \"person to target\" # this describes the value to pass, required = True , type = CommandTypes . USER ) ] ) That's it, simple to create. Verify that the CommandOption.name is something you can name in a normal python function. Let's move to register this command.","title":"Configuring commands"},{"location":"tutorial/Configuring%20commands/#source","text":"from pydantic import BaseModel , validator , Extra import typing from pydantic.error_wrappers import ValidationError from pydantic.errors import ArbitraryTypeError try : from typing import Literal except ImportError : # backport from typing_extensions import Literal class CommandTypes : SUB_COMMAND = 1 SUB_COMMAND_GROUP = 2 STRING = 3 INTEGER = 4 BOOLEAN = 5 USER = 6 CHANNEL = 7 ROLE = 8 class CommandChoice ( BaseModel ): name : str value : str class CommandOption ( BaseModel ): class Config : arbitrary_types_allowed = True extra = Extra . allow name : str description : str type : int required : bool = False choices : typing . Optional [ typing . Union [ typing . List [ dict ], typing . List [ CommandChoice ]] ] = [] # options: typing.Optional[typing.Union[typing.List[CommandChoice]]] # @validator(\"options\") # def options_allow_only_if_subcommand(cls, v): # if cls.type != 1: # raise ValidationError(\"Type must be 1 in order to have options.\") # return v class SubcommandOption ( BaseModel ): class Config : arbitrary_types_allowed = True name : str description : str type : Literal [ 2 ] = 2 options : typing . List [ CommandOption ] @validator ( \"options\" ) def options_must_contain_type_1 ( cls , v ): # pylint: disable=no-self-argument item : CommandOption for item_location , item in enumerate ( v ): if item . type != 1 : raise ValidationError ( f \"CommandOptions located in < { item_location } > must be have type of 1 due to parent being a subcommand.\" ) return v class DiscordCommand ( BaseModel ): name : str description : str options : typing . List [ typing . Union [ SubcommandOption , CommandOption ]]","title":"Source"},{"location":"tutorial/Getting%20Started/","text":"Getting Started Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice","title":"Getting Started"},{"location":"tutorial/Getting%20Started/#getting-started","text":"Let's build a sample bot, this bot will Create a new command Register the new command write a function to accept that command and send something nice","title":"Getting Started"},{"location":"tutorial/Registering%20Commands/","text":"Registering Commands We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register . ( command_to_be_created ) Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict () _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = command . dict () ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#registering-commands","text":"We've created the command, we'll need to register the command with Discord. Info All methods for editing, deleting, registering and getting commands share the same method for globally and guild only. You will need an initialized Dispike object. from dispike import Dispike bot = Dispike ( client_public_key = \"..\" , bot_token = \"..\" , application_id = \"..\" ) bot . register . ( command_to_be_created )","title":"Registering Commands"},{"location":"tutorial/Registering%20Commands/#dispike.register.registrator.RegisterCommands.register","text":"Register a completed DiscordCommand model to Discord API. Parameters: Name Type Description Default command DiscordCommand A properly configured DiscordCommand required guild_only bool Default to set global mode (True). Set to False to let the function know to expect a guild_id False guild_to_target int A guild Id if guild_only is set to True. None Source code in dispike/register/registrator.py def register ( self , command : DiscordCommand , guild_only = False , guild_to_target : int = None ): \"\"\"Register a completed `DiscordCommand` model to Discord API. Args: command (DiscordCommand): A properly configured DiscordCommand guild_only (bool, optional): Default to set global mode (True). Set to False to let the function know to expect a guild_id guild_to_target (int, optional): A guild Id if guild_only is set to True. \"\"\" if guild_only == True : if guild_to_target is None : raise TypeError ( \"if guild_only is set to true, a guild id must be provided.\" ) logger . info ( f \"Targeting a specific guild -> { guild_to_target } \" ) _request_url = f \"guilds/ { guild_to_target } /commands\" else : _request_url = f \"commands\" try : _command_to_json = command . dict () _send_request = self . _client . post ( _request_url , headers = self . request_headers , json = command . dict () ) if _send_request . status_code in [ 200 , 201 ]: return True raise DiscordAPIError ( _send_request . status_code , _send_request . text ) except Exception : raise","title":"dispike.register.registrator.RegisterCommands.register"},{"location":"tutorial/Running%20the%20bot/","text":"Running your bot. Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckilly there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok. Start ngrok. Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification. Start the bot. There is multiple ways to run the bot. We\u2019re going to the most simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass. Run some commands. Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Running The Bot"},{"location":"tutorial/Running%20the%20bot/#running-your-bot","text":"Great, you successfully created, registered, and wrote a handler for a command. We need to run the bot. Info It\u2019s important to remember, when you are ready to deploy your bot, you will need to deploy your bot over a reverse proxy (which is beyond the scope of the docs.). Now, since we don\u2019t have a server set up yet, how are we going to test our bot? It\u2019s a pain in the ass to have a server just for testing. Luckilly there is a tool that can help us. We\u2019re going to use a tool called ngrok . It creates a tunnel that is accessible over the internet to a local port running on your computer. Sign-up and install ngrok.","title":"Running your bot."},{"location":"tutorial/Running%20the%20bot/#start-ngrok","text":"Open a new terminal window, and run ngrok http 5000 Take a note at the HTTPS link, this is the link you will provide to discord. Info If you try to give discord the link, it will fail. The bot is not running and nothing is there to run the first verification.","title":"Start ngrok."},{"location":"tutorial/Running%20the%20bot/#start-the-bot","text":"There is multiple ways to run the bot. We\u2019re going to the most simplest one. Add the following lines to the end of the file containing the bot object and handler if __name__ == \u201c __main__ \u201d : bot . run ( port = 5000 ) Warning This is simple, but is not meant for production! Open your web-browser (or postman) and try to test if your bot is reachable by going to the link that ngrok has provided and appending /ping You should see a message telling you it\u2019s reachable. Afterwards, go to discord and add the interaction point url, with the url that ngrok has provided appended with /interactions Press submit, and Discord will test your link by sending two requests, they should pass.","title":"Start the bot."},{"location":"tutorial/Running%20the%20bot/#run-some-commands","text":"Congrats, if tests pass, invite your bot into a server, and try out some bot commands!","title":"Run some commands."},{"location":"tutorial/Writing%20the%20handler/","text":"Writing your first handler. You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , NotReadyResponse or a dict . Warning If you return a dict , it will not verified and Dispike will assume that\u2019s valid and return the result to discord. Your function must accept the same number of arugments you registered with discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an arugment named person , the function arugment must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python Incoming Context Eariler you learned that you must account for an extra arugment due to Dispike also passing a context about the command to your arugment. Incoming context is type hinted, and your IDE should be able to auto-complete attributes. Writing your function from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . interaction . on ( \"wave\" ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.interaction.on(\u2018wave\u2019) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument named \u201cperson\u201d, as well as the context that we will be reciveing. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests faster, as Dispike would not have to guess what your response type is.","title":"Writing The Handler"},{"location":"tutorial/Writing%20the%20handler/#writing-your-first-handler","text":"You\u2019ve created and registered your first command. Let\u2019s write the handler so it can properly display to the user. It\u2019s a standard function with a few requirements. It must be async ( async def ) It must finally return: DiscordResponse , NotReadyResponse or a dict . Warning If you return a dict , it will not verified and Dispike will assume that\u2019s valid and return the result to discord. Your function must accept the same number of arugments you registered with discord + an incoming context parameter. Dispike will pass the same arguments (with the same names) to your function + incoming context about the request. So if you registered a command with an arugment named person , the function arugment must be the same. Warning Rule of thumb, do not name arguments you are unable to name in standard python","title":"Writing your first handler."},{"location":"tutorial/Writing%20the%20handler/#incoming-context","text":"Eariler you learned that you must account for an extra arugment due to Dispike also passing a context about the command to your arugment. Incoming context is type hinted, and your IDE should be able to auto-complete attributes.","title":"Incoming Context"},{"location":"tutorial/Writing%20the%20handler/#writing-your-function","text":"from discord.models.incoming IncomingDiscordInteraction bot = Dispike ( \u2026 ) @bot . interaction . on ( \"wave\" ) async def handle_send_wave ( person : int , ctx : IncomingDiscordInteraction ) -> DiscordResponse : print ( \u201c recieved wave command \u201d ) # this is what we will be returning. Let's edit it. response = DiscordResponse () response . content f \"\ud83d\udc4b Hi @< { person } >.\" return response Take a look at @bot.interaction.on(\u2018wave\u2019) , you can see that the .on takes in the command name we registered earlier. The function also accepts two arguments. Our registered argument named \u201cperson\u201d, as well as the context that we will be reciveing. Also take a look at -> DiscordResponse , this is a type-hint, this is optional, but it will make your requests faster, as Dispike would not have to guess what your response type is.","title":"Writing your function"}]}